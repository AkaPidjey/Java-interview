[Вопросы для собеседования](README.md)

# Примитивные типы
## Примитивные типы / Переменные / Операторы / Циклы / Массивы
+ [Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?](#Сколько-ключевых-слов-зарезервировано-языком-что-это-за-слова-какие-из-них-не-используются)
+ [Из каких символов может состоять имя переменной (корректный идентификатор)?](#Из-каких-символов-может-состоять-имя-переменной-корректный-идентификатор)
+ [Какие примитивные типы вы знаете?](#Какие-примитивные-типы-вы-знаете)
+ [Какие логические операции и операторы вы знаете?](#Какие-логические-операции-и-операторы-вы-знаете)
+ [Что такое тернарный оператор выбора?](#Что-такое-тернарный-оператор-выбора)
+ [Какие побитовые операции вы знаете?](#Какие-побитовые-операции-вы-знаете)
+ [Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?](#Что-вы-знаете-о-преобразовании-примитивных-типов-данных-есть-ли-потеря-данных-можно-ли-преобразовать-логический-тип)
+ [Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?](#Что-такое-autoboxing-автоупаковка-в-java-и-каковы-правила-упаковки-примитивных-типов-в-классы-обертки)
+ [Какие есть особенности класса `String`?](#Какие-есть-особенности-класса-string)
+ [Почему `String` неизменяемый и финализированный класс?](#Почему-string-неизменяемый-и-финализированный-класс)
+ [Почему `char[]` предпочтительнее `String` для хранения пароля?](#Почему-char-предпочтительнее-string-для-хранения-пароля)
+ [Почему строка является популярным ключом в `HashMap` в Java?](#Почему-строка-является-популярным-ключом-в-hashmap-в-java)
+ [Что делает метод `intern()` в классе `String`?.](#Что-делает-метод-intern-в-классе-string)
+ [Можно ли использовать строки в конструкции `switch`?](#Можно-ли-использовать-строки-в-конструкции-switch)
+ [Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?](#Какая-основная-разница-между-string-stringbuffer-stringbuilder)


## Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?
50, два из них не используются: const, goto;

Для запоминания это:
+ Примитивы (byte, short, int, long, char, float, double, boolean)
+ Циклы и ветвления (if, else, switch, case, default, while, do, break, continue, for)
+ Исключения (try, catch, finally, throw, throws)
+ Области видимости (private, protected, public)
+ Объявление \ Импорт (import, package, class, interface, extends, implements, static, final, void, abstract, native)
+ Создание \ Возврат \ Вызов (new, return, this, super)
+ Многопоточность (synchronized, volatile)
+ instanceof, enum, assert, transient, strictfp, const, goto

http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

[к оглавлению](#примитивные-типы)

## Из каких символов может состоять имя переменной (корректный идентификатор)?
Имя или идентификатор переменной — это последовательность из строчных и заглавных латинских букв, цифр, а также символов «$» и «_». Имя переменной может начинаться с любого из перечисленных символов, кроме цифры.

Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.

[к оглавлению](#примитивные-типы)

## Какие примитивные типы вы знаете?
Примитивные:
+ byte (целые числа, 1 байт, [-128, 127])
+ short (целые числа, 2 байта, [-32768, 32767])
+ int (целые числа, 4 байта, [-2147483648, 2147483647])
+ long (целые числа, 8 байт, [-9223372036854775808,9223372036854775807])
+ float (вещественные числа, 4 байта)
+ double (вещественные числа, 8 байт)
+ char (символ Unicode, 2 байта, [0, 65536])
+ boolean (значение истина/ложь, используется int, зависит от JVM)

Ссылочные. В ссылочные типы входят все классы, интерфейсы, массивы.

http://stackoverflow.com/questions/383551/what-is-the-size-of-a-boolean-variable-in-java
boolean type: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4
boolean — боремся за Java память… https://habrahabr.ru/post/76481/

[к оглавлению](#примитивные-типы)

## Какие логические операции и операторы вы знаете?
+ `&`: Логическое _AND_ (И);
+ `&&`: Сокращённое _AND_;
+ `|`: Логическое _OR_ (ИЛИ);
+ `||`: Сокращённое _OR_;
+ `^`: Логическое _XOR_ (исключающее _OR_ (ИЛИ));
+ `!`: Логическое унарное _NOT_ (НЕ);
+ `&=`: _AND_ с присваиванием;
+ `|=`: _OR_ с присваиванием;
+ `^=`: _XOR_ с присваиванием;
+ `==`: Равно;
+ `!=`: Не равно;
+ `?:`: Тернарный (троичный) условный оператор.

[к оглавлению](#примитивные-типы)


## Что такое тернарный оператор выбора?
Тернарный условный оператор `?:` - оператор, которым можно заменить некоторые конструкции операторов `if-then-else`.

Выражение записывается в следующей форме:
>условие ? выражение1 : выражение2

Если `условие` выполняется, то вычисляется `выражение1` и его результат становится результатом выполнения всего оператора. Если же `условие` равно `false`, то вычисляется `выражение2` и его значение становится результатом работы оператора. Оба операнда `выражение1` и `выражение2` должны возвращать значение одинакового (или совместимого) типа.

[к оглавлению](#примитивные-типы)

## Какие побитовые операции вы знаете?
+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

[к оглавлению](#примитивные-типы)

## Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?
Преобразование может быть неявным и явным (приведение типов). Неявное преобразование может выполняться если:
типы совместимы (например – оба целочисленные)
размер “принимающего” типа больше чем у того, который преобразуется (так называемое “преобразование с расширением”)
```java
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением

Явное преобразование имеет вид переменная_нового_типа = (новый_тип) имя переменной;
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
```
Примеры:
```java
public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0
 
        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }
 
    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127
 
        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56
 
        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }
```
При повышении типа byte>short; short>int; int>long; float>double; char>int информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).

При различных операциях может происходить повышение типов в порядке “усиления” к более информативному типу. Например складывая int и double получим тип double. Но есть и особенность, например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double), а не более “длинный” тип. Аналогичный пример с вещественной частью:
```java
  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0
 
        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0
```
Кратко можно записать такие правила:
+ byte, short, char в выражениях всегда повышаются до int
+ если в выражении участвует тип long – то именно к этому типу будет приведён результат
+ если в выражении участвует float – то результат приводится к float
+ если один из операндов имеет тип double – то к этому типу будет приведён весь результат
+ При выборе между длиной и возможностью сохранить дробную часть – будет выбрана дробная часть

[к оглавлению](#примитивные-типы)

## Что такое _autoboxing («автоупаковка»)_ в Java и каковы правила упаковки примитивных типов в классы-обертки?
__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не дожен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` я вляется то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

[к оглавлению](#примитивные-типы)

## Какие есть особенности класса `String`?
+ Это неизменяемый (immutable) и финализированный тип данных;
+ Все объекты класса `String` JVM хранит в пуле строк;
+ Объект класса `String` можно получить, используя двойные кавычки;
+ Можно использовать оператор `+` для конкатенации строк;
+ Начиная с Java 7 строки можно использовать в конструкции `switch`.

[к оглавлению](#примитивные-типы)

## Почему `String` неизменяемый и финализированный класс?
Есть несколько преимуществ в неизменности строк:

+ Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в _Heap_, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
+ Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
+ Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.
+ Строки используются _classloader_ и неизменность обеспечивает правильность загрузки класса.
+ Поскольку строка неизменяемая, её `hashCode()` кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в `HashMap` т.к. его обработка происходит быстрее.

[к оглавлению](#примитивные-типы)

## Почему `char[]` предпочтительнее `String` для хранения пароля?
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста.
В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.

[к оглавлению](#примитивные-типы)

## Почему строка является популярным ключом в `HashMap` в Java?
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа `HashMap` они будут обрабатываться быстрее.

[к оглавлению](#примитивные-типы)

## Что делает метод `intern()` в классе `String`?.
Метод `intern()` используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.

[к оглавлению](#примитивные-типы)

## Можно ли использовать строки в конструкции `switch`?
Да, начиная с Java 7 в операторе `switch` можно использовать строки, ранние версии Java не поддерживают этого. При этом:

+ участвующие строки чувствительны к регистру;
+ используется метод `equals()` для сравнения полученного значения со значениями `case`, поэтому во избежание `NullPointerException` стоит предусмотреть проверку на `null`.
+ согласно документации, Java 7 для строк в `switch`, компилятор Java формирует более эффективный байткод для строк в конструкции `switch`, чем для сцепленных условий `if`-`else`.

[к оглавлению](#примитивные-типы)

## Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?
Класс `String` является неизменяемым (_immutable_) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс `StringBuffer` изменяемый - использовать `StringBuffer` следует тогда, когда необходимо часто модифицировать содержимое. 

Класс `StringBuilder` был добавлен в Java 5 и он во всем идентичен классу `StringBuffer` за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

[к оглавлению](#примитивные-типы)

[Вопросы для собеседования](README.md)
