[Вопросы для собеседования](README.md)

# Исключения
+ [Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
+ [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)
+ [Когда в приложении может быть выброшено исключение `ClassCastException`?](#Когда-в-приложении-может-быть-выброшено-исключение-classcastexception)
+ [Опишите иерархию исключений.](#Опишите-иерархию-исключений)
+ [Какие виды исключений в Java вы знаете, чем они отличаются?](#Какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются)
+ [Что такое _checked_ и _unchecked exception_?](#Что-такое-checked-и-unchecked-exception)
+ [Какой оператор позволяет принудительно выбросить исключение?](#Какой-оператор-позволяет-принудительно-выбросить-исключение)
+ [О чем говорит ключевое слово `throws`?](#О-чем-говорит-ключевое-слово-throws)
+ [Как написать собственное («пользовательское») исключение?](#Как-написать-собственное-пользовательское-исключение)
+ [Какие существуют _unchecked exception_?](#Какие-существуют-unchecked-exception)
+ [Что представляет из себя ошибки класса `Error`?](#Что-представляет-из-себя-ошибки-класса-error)
+ [Что вы знаете о `OutOfMemoryError`?](#Что-вы-знаете-о-outofmemoryerror)
+ [Опишите работу блока _try-catch-finally_.](#Опишите-работу-блока-try-catch-finally)
+ [Что такое механизм _try-with-resources_?](#Что-такое-механизм-try-with-resources)
+ [Возможно ли использование блока _try-finally_ (без `catch`)?](#Возможно-ли-использование-блока-try-finally-без-catch)
+ [Может ли один блок `catch` отлавливать сразу несколько исключений?](#Может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
+ [Всегда ли исполняется блок `finally`?](#Всегда-ли-исполняется-блок-finally)
+ [Существуют ли ситуации, когда блок `finally` не будет выполнен?](#Существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)
+ [Может ли метод _main()_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#Может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
+ [Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?](#Предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-Сколько-блоков-catch-будет-выполнено)

## Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в `throws` всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

[к оглавлению](#исключения)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник `RuntimeException`:

+ для статических блоков инициализации будет выброшено `java.lang.ExceptionInInitializerError`;
+ для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник `Error`, то в обоих случаях будет выброшено `java.lang.Error`. Исключение: `java.lang.ThreadDeath` - смерть потока. В этом случае никакое исключение выброшено не будет.

[к оглавлению](#исключения)

## Когда в приложении может быть выброшено исключение `ClassCastException`?
`ClassCastException` (потомок `RuntimeException`) - исключение, которое будет выброшено при ошибке приведения типа.

[к оглавлению](#исключения)

## Опишите иерархию исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс `Throwable`, потомками которого являются классы `Exception` и `Error`.

__Ошибки (Errors)__ представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.

__Исключения (Exceptions)__ являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.

[к оглавлению](#исключения)

## Какие виды исключений в Java вы знаете, чем они отличаются?
## Что такое _checked_ и _unchecked exception_?
В Java все исключения делятся на два типа:

+ __checked (контролируемые/проверяемые исключения)__ должны обрабатываться блоком `catch` или описываться в сигнатуре метода (например, `throws IOException`). Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;
+ __unchecked (неконтролируемые/непроверяемые исключения)__, к которым относятся ошибки `Error` (например, `OutOfMemoryError`), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом `RuntimeException` и его наследниками (например, `NullPointerException`), которые могут не обрабатываться блоком `catch` и не быть описанными в сигнатуре метода.

[к оглавлению](#исключения)

## Какой оператор позволяет принудительно выбросить исключение?
Это оператор `throw`:

```java
throw new Exception();
```

[к оглавлению](#исключения)

## О чем говорит ключевое слово `throws`?
Модификатор `throws` прописывается в сигнатуре метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.

[к оглавлению](#исключения)

## Как написать собственное («пользовательское») исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например от `Exception` или `RuntimeException`).

```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```

[к оглавлению](#исключения)

## Какие существуют _unchecked exception_?
Наиболее часто встречающиеся: `ArithmeticException`, `ClassCastException`, `ConcurrentModificationException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`, `NoSuchElementException`, `NullPointerException`, `UnsupportedOperationException`.

[к оглавлению](#исключения)

## Что представляет из себя ошибки класса `Error`?
Ошибки класса `Error` представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.

[к оглавлению](#исключения)

## Что вы знаете о `OutOfMemoryError`?
`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

+ `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
+ `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
+ `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
+ `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

[к оглавлению](#исключения)

## Опишите работу блока _try-catch-finally_.
`try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
`catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.
`finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```

[к оглавлению](#исключения)

## Что такое механизм _try-with-resources_?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок _try-catch_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`. 

Общий вид конструкции:

```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```

Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.

[к оглавлению](#исключения)

## Возможно ли использование блока _try-finally_ (без `catch`)?
Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок `catch`, в котором будет обрабатываться необходимое исключение.

[к оглавлению](#исключения)

## Может ли один блок `catch` отлавливать сразу несколько исключений?
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком `catch`:

```java
try {  
    //...
} catch(IOException | SQLException ex) {
    //...
}
```

[к оглавлению](#исключения)

## Всегда ли исполняется блок `finally`?
Код в блоке `finally` будет выполнен всегда, независимо от того, выброшено исключение или нет.

[к оглавлению](#исключения)

## Существуют ли ситуации, когда блок `finally` не будет выполнен?
Например, когда JVM «умирает» - в такой ситуации `finally` недостижим и не будет выполнен, так как происходит принудительный системный выход из программы:

```java
try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }
```

[к оглавлению](#исключения)

## Может ли метод _main()_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).

[к оглавлению](#исключения)

## Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?
Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```

[к оглавлению](#исключения)




[Вопросы для собеседования](README.md)
